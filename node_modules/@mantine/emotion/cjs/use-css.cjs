'use client';
'use strict';

var serialize = require('@emotion/serialize');
var utils = require('@emotion/utils');
var clsx = require('clsx');
var MantineEmotionProvider = require('./MantineEmotionProvider.cjs');
var useGuaranteedMemo = require('./use-guaranteed-memo.cjs');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var clsx__default = /*#__PURE__*/_interopDefault(clsx);

const refPropertyName = "ref";
function getRef(args) {
  let ref;
  if (args.length !== 1) {
    return { args, ref };
  }
  const [arg] = args;
  if (!(arg instanceof Object)) {
    return { args, ref };
  }
  if (!(refPropertyName in arg)) {
    return { args, ref };
  }
  ref = arg[refPropertyName];
  const argCopy = { ...arg };
  delete argCopy[refPropertyName];
  return { args: [argCopy], ref };
}
const { cssFactory } = /* @__PURE__ */ (() => {
  function merge(registered, css, className) {
    const registeredStyles = [];
    const rawClassName = utils.getRegisteredStyles(registered, registeredStyles, className);
    if (registeredStyles.length < 2) {
      return className;
    }
    return rawClassName + css(registeredStyles);
  }
  function _cssFactory(params) {
    const { cache } = params;
    const css = (...styles) => {
      const { ref, args } = getRef(styles);
      const serialized = serialize.serializeStyles(args, cache.registered);
      utils.insertStyles(cache, serialized, false);
      return `${cache.key}-${serialized.name}${ref === void 0 ? "" : ` ${ref}`}`;
    };
    const cx = (...args) => merge(cache.registered, css, clsx__default.default(args));
    return { css, cx };
  }
  return { cssFactory: _cssFactory };
})();
function useCss() {
  const cache = MantineEmotionProvider.useEmotionCache();
  return useGuaranteedMemo.useGuaranteedMemo(() => cssFactory({ cache }), [cache]);
}

exports.cssFactory = cssFactory;
exports.useCss = useCss;
//# sourceMappingURL=use-css.cjs.map
